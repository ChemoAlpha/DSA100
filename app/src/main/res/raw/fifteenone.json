{
  "problem_statement": {
    "title": "Q93. Breadth-First Search (BFS) on a Graph",
    "problemdescription": "Given an undirected graph, implement breadth-first search (BFS) to traverse the graph and print the vertices in BFS order starting from a specified source vertex.",
    "problemconstraint": "Constraints:\n- The graph is represented as an adjacency list.\n- You need to implement the BFS algorithm iteratively using a queue.",
    "inputformat": "Input:\n- An undirected graph represented as an adjacency list.\n- An integer `source` representing the source vertex from where BFS traversal should start.",
    "outputformat": "Output:\n- Print the vertices of the graph in BFS order starting from the source vertex.",
    "example": "Example:\n\n```\nInput:\ngraph = {\n    0: [1, 2],\n    1: [0, 3, 4],\n    2: [0, 4],\n    3: [1],\n    4: [1, 2]\n}\nsource = 0\n\nOutput (BFS Order): 0 1 2 3 4\n```"
  },
  "solution_approach": {
    "solution": "To implement Breadth-First Search (BFS) on a graph, you can use an iterative approach with a queue. Here's an algorithmic approach:\n\n1. Create a queue to perform BFS traversal.\n2. Enqueue the source vertex onto the queue and mark it as visited.\n3. While the queue is not empty:\n   - Dequeue a vertex from the queue and print it (this is the BFS order).\n   - Get all adjacent vertices of the dequeued vertex that have not been visited.\n   - Enqueue these unvisited adjacent vertices onto the queue and mark them as visited.\n4. Continue this process until the queue becomes empty.\n5. This algorithm ensures that vertices are explored in BFS order starting from the source vertex.",
    "hint": "Use a data structure to keep track of visited vertices and avoid processing them multiple times during BFS traversal."
  },
  "solution": {
    "java": "Here's a Java solution to perform Breadth-First Search (BFS) on a graph represented as an adjacency list:\n\n```java\nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.Queue;\n\npublic class GraphBFS {\n    private int vertices;\n    private ArrayList<ArrayList<Integer>> adjacencyList;\n\n    public GraphBFS(int vertices) {\n        this.vertices = vertices;\n        adjacencyList = new ArrayList<>(vertices);\n        for (int i = 0; i < vertices; i++) {\n            adjacencyList.add(new ArrayList<>());\n        }\n    }\n\n    public void addEdge(int vertex, int neighbor) {\n        adjacencyList.get(vertex).add(neighbor);\n        adjacencyList.get(neighbor).add(vertex);\n    }\n\n    public void performBFS(int source) {\n        boolean[] visited = new boolean[vertices];\n        Queue<Integer> queue = new LinkedList<>();\n        queue.offer(source);\n        visited[source] = true;\n\n        while (!queue.isEmpty()) {\n            int currentVertex = queue.poll();\n            System.out.print(currentVertex + \" \");\n\n            for (int neighbor : adjacencyList.get(currentVertex)) {\n                if (!visited[neighbor]) {\n                    queue.offer(neighbor);\n                    visited[neighbor] = true;\n                }\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        int vertices = 5;\n        GraphBFS graph = new GraphBFS(vertices);\n        graph.addEdge(0, 1);\n        graph.addEdge(0, 2);\n        graph.addEdge(1, 3);\n        graph.addEdge(1, 4);\n\n        System.out.println(\"BFS Order from source 0:\");\n        graph.performBFS(0);\n    }\n}\n```",
    "python": "And here's a Python solution to perform Breadth-First Search (BFS) on a graph represented as an adjacency list:\n\n```python\nfrom collections import defaultdict, deque\n\nclass GraphBFS:\n    def __init__(self, vertices):\n        self.vertices = vertices\n        self.adjacency_list = defaultdict(list)\n\n    def add_edge(self, vertex, neighbor):\n        self.adjacency_list[vertex].append(neighbor)\n        self.adjacency_list[neighbor].append(vertex)\n\n    def perform_bfs(self, source):\n        visited = [False] * self.vertices\n        queue = deque([source])\n        visited[source] = True\n\n        while queue:\n            current_vertex = queue.popleft()\n            print(current_vertex, end=' ')\n\n            for neighbor in self.adjacency_list[current_vertex]:\n                if not visited[neighbor]:\n                    queue.append(neighbor)\n                    visited[neighbor] = True\n\nif __name__ == '__main__':\n    vertices = 5\n    graph = GraphBFS(vertices)\n    graph.add_edge(0, 1)\n    graph.add_edge(0, 2)\n    graph.add_edge(1, 3)\n    graph.add_edge(1, 4)\n\n    print('BFS Order from source 0:')\n    graph.perform_bfs(0)\n```"
  },
  "extras": {
    "asked": "Implementing Breadth-First Search (BFS) on a graph is a fundamental algorithmic problem used in various applications, including shortest path algorithms and network analysis.",
    "sdesheet": "This problem is often included in coding practice sheets to help candidates practice graph traversal algorithms and data structure concepts.",
    "relatedlinks": "Related Links:\n- [Breadth-First Search (BFS) on Wikipedia](https://en.wikipedia.org/wiki/Breadth-first_search)\n- [GeeksforGeeks BFS Article](https://www.geeksforgeeks.org/breadth-first-search-or-bfs-for-a-graph/)\n- [HackerRank BFS Tutorial](https://www.hackerrank.com/challenges/ctci-bfs-shortest-reach/tutorial)"
  }
}
