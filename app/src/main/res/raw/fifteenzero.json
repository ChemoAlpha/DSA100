{
  "problem_statement": {
    "title": "Q92. Depth-First Search (DFS) on a Graph",
    "problemdescription": "Given an undirected graph, implement depth-first search (DFS) to traverse the graph and print the vertices in DFS order starting from a specified source vertex.",
    "problemconstraint": "Constraints:\n- The graph is represented as an adjacency list.\n- You need to implement the DFS algorithm iteratively using a stack.",
    "inputformat": "Input:\n- An undirected graph represented as an adjacency list.\n- An integer `source` representing the source vertex from where DFS traversal should start.",
    "outputformat": "Output:\n- Print the vertices of the graph in DFS order starting from the source vertex.",
    "example": "Example:\n\n```\nInput:\ngraph = {\n    0: [1, 2],\n    1: [0, 3, 4],\n    2: [0, 4],\n    3: [1],\n    4: [1, 2]\n}\nsource = 0\n\nOutput (DFS Order): 0 2 4 1 3\n```"
  },
  "solution_approach": {
    "solution": "To implement Depth-First Search (DFS) on a graph, you can use an iterative approach with a stack. Here's an algorithmic approach:\n\n1. Create a stack to perform DFS traversal.\n2. Push the source vertex onto the stack and mark it as visited.\n3. While the stack is not empty:\n   - Pop a vertex from the stack and print it (this is the DFS order).\n   - Get all adjacent vertices of the popped vertex that have not been visited.\n   - Push these unvisited adjacent vertices onto the stack and mark them as visited.\n4. Continue this process until the stack becomes empty.\n5. This algorithm ensures that vertices are explored in DFS order starting from the source vertex.",
    "hint": "Use a data structure to keep track of visited vertices and avoid processing them multiple times during DFS traversal."
  },
  "solution": {
    "java": "Here's a Java solution to perform Depth-First Search (DFS) on a graph represented as an adjacency list:\n\n```java\nimport java.util.ArrayList;\nimport java.util.Stack;\n\npublic class GraphDFS {\n    private int vertices;\n    private ArrayList<ArrayList<Integer>> adjacencyList;\n\n    public GraphDFS(int vertices) {\n        this.vertices = vertices;\n        adjacencyList = new ArrayList<>(vertices);\n        for (int i = 0; i < vertices; i++) {\n            adjacencyList.add(new ArrayList<>());\n        }\n    }\n\n    public void addEdge(int vertex, int neighbor) {\n        adjacencyList.get(vertex).add(neighbor);\n        adjacencyList.get(neighbor).add(vertex);\n    }\n\n    public void performDFS(int source) {\n        boolean[] visited = new boolean[vertices];\n        Stack<Integer> stack = new Stack<>();\n        stack.push(source);\n\n        while (!stack.isEmpty()) {\n            int currentVertex = stack.pop();\n            if (!visited[currentVertex]) {\n                System.out.print(currentVertex + \" \");\n                visited[currentVertex] = true;\n\n                for (int neighbor : adjacencyList.get(currentVertex)) {\n                    if (!visited[neighbor]) {\n                        stack.push(neighbor);\n                    }\n                }\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        int vertices = 5;\n        GraphDFS graph = new GraphDFS(vertices);\n        graph.addEdge(0, 1);\n        graph.addEdge(0, 2);\n        graph.addEdge(1, 3);\n        graph.addEdge(1, 4);\n\n        System.out.println(\"DFS Order from source 0:\");\n        graph.performDFS(0);\n    }\n}\n```",
    "python": "And here's a Python solution to perform Depth-First Search (DFS) on a graph represented as an adjacency list:\n\n```python\nfrom collections import defaultdict\n\nclass GraphDFS:\n    def __init__(self, vertices):\n        self.vertices = vertices\n        self.adjacency_list = defaultdict(list)\n\n    def add_edge(self, vertex, neighbor):\n        self.adjacency_list[vertex].append(neighbor)\n        self.adjacency_list[neighbor].append(vertex)\n\n    def perform_dfs(self, source):\n        visited = [False] * self.vertices\n        stack = [source]\n\n        while stack:\n            current_vertex = stack.pop()\n            if not visited[current_vertex]:\n                print(current_vertex, end=' ')\n                visited[current_vertex] = True\n\n                for neighbor in self.adjacency_list[current_vertex]:\n                    if not visited[neighbor]:\n                        stack.append(neighbor)\n\nif __name__ == '__main__':\n    vertices = 5\n    graph = GraphDFS(vertices)\n    graph.add_edge(0, 1)\n    graph.add_edge(0, 2)\n    graph.add_edge(1, 3)\n    graph.add_edge(1, 4)\n\n    print('DFS Order from source 0:')\n    graph.perform_dfs(0)\n```"
  },
  "extras": {
    "asked": "Implementing Depth-First Search (DFS) on a graph is a fundamental algorithmic problem used in various applications, including graph traversal and connectivity analysis.",
    "sdesheet": "This problem is often included in coding practice sheets to help candidates practice graph traversal algorithms and data structure concepts.",
    "relatedlinks": "Related Links:\n- [Depth-First Search (DFS) on Wikipedia](https://en.wikipedia.org/wiki/Depth-first_search)\n- [GeeksforGeeks DFS Article](https://www.geeksforgeeks.org/depth-first-search-or-dfs-for-a-graph/)\n- [HackerRank DFS Tutorial](https://www.hackerrank.com/challenges/ctci-connected-cell-in-a-grid/tutorial)"
  }
}
