{
  "problem_statement": {
    "title": "Q99. Bellman-Ford Algorithm",
    "problemdescription": "Given a weighted, directed graph and a source vertex `s`, implement the Bellman-Ford algorithm to find the shortest distances from the source vertex `s` to all other vertices in the graph. The algorithm should also detect and report negative weight cycles if present.",
    "problemconstraint": "Constraints:\n- The input graph is a weighted, directed graph with at most 10^5 vertices and 10^6 edges.\n- Edge weights can be negative integers.\n- The source vertex `s` is one of the vertices in the graph.",
    "inputformat": "Input:\n- An integer `n` representing the number of vertices in the graph.\n- An integer `m` representing the number of edges in the graph.\n- A list of `m` triples representing the edges of the graph. Each triple is of the form `[u, v, w]`, indicating a directed edge from vertex `u` to vertex `v` with weight `w`.\n- An integer `s` representing the source vertex.",
    "outputformat": "Output:\n- Return a list of integers where the `i`-th element represents the shortest distance from the source vertex `s` to vertex `i`. If a vertex is not reachable from the source, its distance should be infinity (or a very large value). If a negative weight cycle is detected, return a special value to indicate its presence.",
    "example": "Example:\n\n```\nInput:\nn = 5, m = 8\nedges = [[0, 1, -1], [0, 2, 4], [1, 2, 3], [1, 3, 2], [1, 4, 2], [3, 2, 5], [3, 1, 1], [4, 3, -3]]\ns = 0\n\nOutput: [0, -1, 2, -2, 1]\nExplanation: Using the Bellman-Ford algorithm, the shortest distances from source vertex 0 to all other vertices are [0, -1, 2, -2, 1].\n```"
  },
  "solution_approach": {
    "solution": "The Bellman-Ford algorithm finds the shortest distances from a source vertex to all other vertices in a weighted, directed graph, and it can also detect negative weight cycles. Here's an algorithmic approach:\n\n1. Initialize an array `dist` of size `n` (number of vertices) to store the shortest distances from the source vertex to all other vertices. Initialize `dist` with a large value (e.g., infinity) except for the source vertex, which is initialized to 0.\n2. Repeat the following steps `n-1` times (where `n` is the number of vertices):\n   - For each edge `[u, v, w]` in the graph, if `dist[u] + w < dist[v]`, update `dist[v]` to `dist[u] + w`.\n3. After `n-1` iterations, `dist` contains the shortest distances from the source vertex to all other vertices, assuming there are no negative weight cycles. To detect negative weight cycles, repeat step 2 once more, and if any `dist[v]` changes during this iteration, it indicates the presence of a negative weight cycle.\n4. Return `dist` as the result. If a vertex is not reachable from the source, its distance should remain as infinity (or a very large value), and if a negative weight cycle is detected, return a special value to indicate its presence.",
    "hint": "To efficiently detect negative weight cycles, keep track of the vertices that changed during the last iteration. If any of these vertices have an outgoing edge to `v` with `dist[v]` updated during the `n`-th iteration, it indicates a negative weight cycle."
  },
  "solution": {
    "java": "Here's a Java solution to implement the Bellman-Ford algorithm:\n\n```java\nimport java.util.Arrays;\n\nclass BellmanFord {\n    private int n;\n    private int[][] edges;\n\n    public BellmanFord(int n, int[][] edges) {\n        this.n = n;\n        this.edges = edges;\n    }\n\n    public int[] shortestPath(int s) {\n        int[] dist = new int[n];\n        Arrays.fill(dist, Integer.MAX_VALUE);\n        dist[s] = 0;\n\n        for (int i = 0; i < n - 1; i++) {\n            for (int[] edge : edges) {\n                int u = edge[0];\n                int v = edge[1];\n                int w = edge[2];\n                if (dist[u] != Integer.MAX_VALUE && dist[u] + w < dist[v]) {\n                    dist[v] = dist[u] + w;\n                }\n            }\n        }\n\n        // Check for negative weight cycles\n        boolean hasNegativeCycle = false;\n        for (int[] edge : edges) {\n            int u = edge[0];\n            int v = edge[1];\n            int w = edge[2];\n            if (dist[u] != Integer.MAX_VALUE && dist[u] + w < dist[v]) {\n                hasNegativeCycle = true;\n                break;\n            }\n        }\n\n        if (hasNegativeCycle) {\n            // Negative weight cycle detected\n            return new int[n];\n        }\n\n        return dist;\n    }\n}\n```",
    "python": "And here's a Python solution to implement the Bellman-Ford algorithm:\n\n```python\nclass BellmanFord:\n    def __init__(self, n, edges):\n        self.n = n\n        self.edges = edges\n\n    def shortest_path(self, s):\n        dist = [float('inf')] * self.n\n        dist[s] = 0\n\n        for i in range(self.n - 1):\n            for u, v, w in self.edges:\n                if dist[u] != float('inf') and dist[u] + w < dist[v]:\n                    dist[v] = dist[u] + w\n\n        # Check for negative weight cycles\n        has_negative_cycle = False\n        for u, v, w in self.edges:\n            if dist[u] != float('inf') and dist[u] + w < dist[v]:\n                has_negative_cycle = True\n                break\n\n        if has_negative_cycle:\n            # Negative weight cycle detected\n            return [0] * self.n\n\n        return dist\n```"
  },
  "extras": {
    "asked": "Implementing the Bellman-Ford algorithm is a fundamental problem in graph theory and is widely used in various applications, including network routing and critical path analysis.",
    "sdesheet": "This problem is often included in coding practice sheets to help candidates practice dynamic programming techniques and graph algorithms.",
    "relatedlinks": "Related Links:\n- [Bellman-Ford Algorithm on GeeksforGeeks](https://www.geeksforgeeks.org/bellman-ford-algorithm-dp-23/)\n- [Shortest Path Algorithms on GeeksforGeeks](https://www.geeksforgeeks.org/shortest-path-algorithms/)\n- [HackerRank Bellman-Ford Algorithm Challenge](https://www.hackerrank.com/domains/tutorials/10-days-of-algorithms)"
  }
}
