{
  "problem_statement": {
    "title": "Q66. Design Circular Queue",
    "problemdescription": "Design a circular queue that supports the following operations:\n\n1. `MyCircularQueue(k)`: Initializes the circular queue with a maximum size of `k`.\n2. `enQueue(value)`: Inserts an element into the circular queue. If the queue is full, return `false`.\n3. `deQueue()`: Deletes an element from the circular queue. If the queue is empty, return `false`.\n4. `Front()`: Gets the front item from the queue. If the queue is empty, return `-1`.\n5. `Rear()`: Gets the last item from the queue. If the queue is empty, return `-1`.\n6. `isEmpty()`: Checks whether the circular queue is empty.\n7. `isFull()`: Checks whether the circular queue is full.",
    "problemconstraint": "Constraints:\n- 1 <= `k` <= 1000\n- 0 <= `value` <= 1000\n- At most `k` calls will be made to `enQueue`, `deQueue`, `Front`, `Rear`, `isEmpty`, and `isFull`.",
    "inputformat": "Input:\n- The operations will be given as a list of strings, where each string is one of the supported operations.",
    "outputformat": "Output:\n- For each `enQueue`, `deQueue`, `Front`, `Rear`, `isEmpty`, and `isFull` operation, return the corresponding result as described above.",
    "example": "Example:\n\nInput:\n[\"MyCircularQueue\",\"enQueue\",\"enQueue\",\"enQueue\",\"enQueue\",\"Rear\",\"isFull\",\"deQueue\",\"enQueue\",\"Rear\"]\n[[3],[1],[2],[3],[4],[],[],[],[4],[]]\nOutput:\n[null,true,true,true,false,3,true,true,true,true]\nExplanation:\nMyCircularQueue myCircularQueue = new MyCircularQueue(3);\nmyCircularQueue.enQueue(1); // return true\nmyCircularQueue.enQueue(2); // return true\nmyCircularQueue.enQueue(3); // return true\nmyCircularQueue.enQueue(4); // return false (the queue is full)\nmyCircularQueue.Rear();     // return 3\nmyCircularQueue.isFull();   // return true\nmyCircularQueue.deQueue();  // return true\nmyCircularQueue.enQueue(4); // return true\nmyCircularQueue.Rear();     // return 4"
  },
  "solution_approach": {
    "solution": "To design a circular queue, you can use an array of fixed size `k` and two pointers, `front` and `rear`, to keep track of the front and rear elements of the queue. You need to handle wrap-around when the `front` or `rear` pointer reaches the end of the array. Implement the required operations accordingly.",
    "hint": "Use an array of size `k` and two pointers (`front` and `rear`) to efficiently implement a circular queue."
  },
  "solution": {
    "java": "Here's a Java solution to design a circular queue:\n\n```java\nclass MyCircularQueue {\n    private int[] queue;\n    private int front, rear, size;\n\n    public MyCircularQueue(int k) {\n        queue = new int[k];\n        front = rear = -1;\n        size = 0;\n    }\n\n    public boolean enQueue(int value) {\n        if (isFull()) {\n            return false;\n        }\n        if (isEmpty()) {\n            front = rear = 0;\n        } else {\n            rear = (rear + 1) % queue.length;\n        }\n        queue[rear] = value;\n        size++;\n        return true;\n    }\n\n    public boolean deQueue() {\n        if (isEmpty()) {\n            return false;\n        }\n        if (front == rear) {\n            front = rear = -1;\n        } else {\n            front = (front + 1) % queue.length;\n        }\n        size--;\n        return true;\n    }\n\n    public int Front() {\n        return isEmpty() ? -1 : queue[front];\n    }\n\n    public int Rear() {\n        return isEmpty() ? -1 : queue[rear];\n    }\n\n    public boolean isEmpty() {\n        return size == 0;\n    }\n\n    public boolean isFull() {\n        return size == queue.length;\n    }\n}\n```",
    "python": "And here's a Python solution to design a circular queue:\n\n```python\nclass MyCircularQueue:\n    def __init__(self, k: int):\n        self.queue = [0] * k\n        self.front = self.rear = -1\n        self.size = 0\n        self.k = k\n\n    def enQueue(self, value: int) -> bool:\n        if self.isFull():\n            return False\n        if self.isEmpty():\n            self.front = self.rear = 0\n        else:\n            self.rear = (self.rear + 1) % self.k\n        self.queue[self.rear] = value\n        self.size += 1\n        return True\n\n    def deQueue(self) -> bool:\n        if self.isEmpty():\n            return False\n        if self.front == self.rear:\n            self.front = self.rear = -1\n        else:\n            self.front = (self.front + 1) % self.k\n        self.size -= 1\n        return True\n\n    def Front(self) -> int:\n        return -1 if self.isEmpty() else self.queue[self.front]\n\n    def Rear(self) -> int:\n        return -1 if self.isEmpty() else self.queue[self.rear]\n\n    def isEmpty(self) -> bool:\n        return self.size == 0\n\n    def isFull(self) -> bool:\n        return self.size == self.k\n```"
  },
  "extras": {
    "asked": "Designing a circular queue is a common interview question that assesses your understanding of data structures and queue operations.",
    "sdesheet": "This problem is often included in coding practice sheets to help candidates practice circular queue design and implementation.",
    "relatedlinks": "Related Links:\n- [LeetCode Design Circular Queue Problem](https://leetcode.com/problems/design-circular-queue/)\n- [GeeksforGeeks Circular Queue Article](https://www.geeksforgeeks.org/circular-queue-set-1-introduction-array-implementation/)"
  }
}
