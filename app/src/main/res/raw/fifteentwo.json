{
  "problem_statement": {
    "title": "Q94. Detect a Cycle in an Undirected Graph",
    "problemdescription": "Given an undirected graph, implement an algorithm to detect whether it contains a cycle or not.",
    "problemconstraint": "Constraints:\n- The graph is represented as an adjacency list.\n- You need to implement a cycle detection algorithm for undirected graphs.",
    "inputformat": "Input:\n- An undirected graph represented as an adjacency list.",
    "outputformat": "Output:\n- Return `true` if the graph contains a cycle, and `false` otherwise.",
    "example": "Example:\n\n```\nInput:\ngraph = {\n    0: [1, 2],\n    1: [0, 2],\n    2: [0, 1, 3],\n    3: [2]\n}\n\nOutput: true\nExplanation: The graph contains a cycle (0 -> 2 -> 1 -> 0), so the function returns `true`.\n```"
  },
  "solution_approach": {
    "solution": "To detect a cycle in an undirected graph, you can use Depth-First Search (DFS). Here's an algorithmic approach:\n\n1. Create a function for DFS traversal.\n2. Start DFS traversal from each unvisited node (vertex) in the graph.\n3. During DFS traversal, maintain a visited set to keep track of visited nodes and a parent node to keep track of the parent of the current node being explored.\n4. If, during DFS traversal, you encounter a node that is already visited and is not the parent of the current node, it means you have found a cycle, and you can return `true`.\n5. If you finish DFS traversal without finding any cycles, return `false`.\n6. Repeat this process for all unvisited nodes to cover all connected components of the graph.\n7. If any DFS traversal detects a cycle, the function returns `true`, indicating that the graph contains a cycle.",
    "hint": "You can use a depth-first search approach to explore the graph, and for each edge, check if the adjacent node is already visited and not the parent of the current node being explored."
  },
  "solution": {
    "java": "Here's a Java solution to detect a cycle in an undirected graph using Depth-First Search (DFS):\n\n```java\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\npublic class GraphCycleDetection {\n    private int vertices;\n    private List<List<Integer>> adjacencyList;\n\n    public GraphCycleDetection(int vertices) {\n        this.vertices = vertices;\n        adjacencyList = new ArrayList<>(vertices);\n        for (int i = 0; i < vertices; i++) {\n            adjacencyList.add(new ArrayList<>());\n        }\n    }\n\n    public void addEdge(int u, int v) {\n        adjacencyList.get(u).add(v);\n        adjacencyList.get(v).add(u);\n    }\n\n    public boolean hasCycle() {\n        Set<Integer> visited = new HashSet<>();\n        for (int i = 0; i < vertices; i++) {\n            if (!visited.contains(i) && hasCycleDFS(i, -1, visited)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private boolean hasCycleDFS(int current, int parent, Set<Integer> visited) {\n        visited.add(current);\n        for (int neighbor : adjacencyList.get(current)) {\n            if (!visited.contains(neighbor)) {\n                if (hasCycleDFS(neighbor, current, visited)) {\n                    return true;\n                }\n            } else if (neighbor != parent) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        int vertices = 4;\n        GraphCycleDetection graph = new GraphCycleDetection(vertices);\n        graph.addEdge(0, 1);\n        graph.addEdge(1, 2);\n        graph.addEdge(2, 0);\n\n        boolean containsCycle = graph.hasCycle();\n        System.out.println(\"Graph contains cycle: \" + containsCycle);\n    }\n}\n```",
    "python": "And here's a Python solution to detect a cycle in an undirected graph using Depth-First Search (DFS):\n\n```python\nfrom collections import defaultdict\n\nclass GraphCycleDetection:\n    def __init__(self, vertices):\n        self.vertices = vertices\n        self.adjacency_list = defaultdict(list)\n\n    def add_edge(self, u, v):\n        self.adjacency_list[u].append(v)\n        self.adjacency_list[v].append(u)\n\n    def has_cycle(self):\n        visited = set()\n        for i in range(self.vertices):\n            if i not in visited and self.has_cycle_dfs(i, -1, visited):\n                return True\n        return False\n\n    def has_cycle_dfs(self, current, parent, visited):\n        visited.add(current)\n        for neighbor in self.adjacency_list[current]:\n            if neighbor not in visited:\n                if self.has_cycle_dfs(neighbor, current, visited):\n                    return True\n            elif neighbor != parent:\n                return True\n        return False\n\nif __name__ == '__main__':\n    vertices = 4\n    graph = GraphCycleDetection(vertices)\n    graph.add_edge(0, 1)\n    graph.add_edge(1, 2)\n    graph.add_edge(2, 0)\n\n    contains_cycle = graph.has_cycle()\n    print(f'Graph contains cycle: {contains_cycle}')\n```"
  },
  "extras": {
    "asked": "Detecting a cycle in an undirected graph is a fundamental problem in graph theory and algorithm design.",
    "sdesheet": "This problem is often included in coding practice sheets and technical interviews to assess a candidate's understanding of graph algorithms and cycle detection.",
    "relatedlinks": "Related Links:\n- [Cycle Detection in Undirected Graphs on GeeksforGeeks](https://www.geeksforgeeks.org/detect-cycle-undirected-graph/)\n- [HackerRank Detect a Cycle in a Graph Challenge](https://www.hackerrank.com/challenges/ctci-bfs-shortest-reach/problem)"
  }
}
