{
  "problem_statement": {
    "title": "Q98. Dijkstra's Shortest Path Algorithm",
    "problemdescription": "Given a weighted, directed graph and a source vertex `s`, implement Dijkstra's shortest path algorithm to find the shortest distances from the source vertex `s` to all other vertices in the graph.",
    "problemconstraint": "Constraints:\n- The input graph is a weighted, directed graph with at most 10^5 vertices and 10^6 edges.\n- All edge weights are non-negative integers.\n- The source vertex `s` is one of the vertices in the graph.",
    "inputformat": "Input:\n- An integer `n` representing the number of vertices in the graph.\n- An integer `m` representing the number of edges in the graph.\n- A list of `m` triples representing the edges of the graph. Each triple is of the form `[u, v, w]`, indicating a directed edge from vertex `u` to vertex `v` with weight `w`.\n- An integer `s` representing the source vertex.",
    "outputformat": "Output:\n- Return a list of integers where the `i`-th element represents the shortest distance from the source vertex `s` to vertex `i`. If a vertex is not reachable from the source, its distance should be -1.",
    "example": "Example:\n\n```\nInput:\nn = 6, m = 9\nedges = [[0, 1, 4], [0, 2, 2], [1, 2, 5], [1, 3, 10], [2, 4, 3], [3, 4, 4], [3, 5, 7], [4, 5, 2], [5, 0, 6]]\ns = 0\n\nOutput: [0, 4, 2, 9, 5, 11]\nExplanation: Using Dijkstra's algorithm, the shortest distances from source vertex 0 to all other vertices are [0, 4, 2, 9, 5, 11].\n```"
  },
  "solution_approach": {
    "solution": "Dijkstra's shortest path algorithm finds the shortest distances from a source vertex to all other vertices in a weighted, directed graph. Here's an algorithmic approach:\n\n1. Initialize an array `dist` of size `n` (number of vertices) to store the shortest distances from the source vertex to all other vertices. Initialize `dist` with a large value (e.g., infinity) except for the source vertex, which is initialized to 0.\n2. Create a set `visited` to keep track of visited vertices.\n3. Repeat the following steps until all vertices are visited:\n   - Find the vertex `u` with the minimum distance in `dist` that is not in `visited`.\n   - Mark `u` as visited by adding it to `visited`.\n   - Update the distances to its neighbors `v` (adjacent vertices) as follows:\n     - If `dist[u] + weight(u, v) < dist[v]`, update `dist[v]` to `dist[u] + weight(u, v)`.\n4. Once all vertices are visited or unreachable, `dist` contains the shortest distances from the source vertex to all other vertices.\n5. Return `dist` as the result.",
    "hint": "You can use a priority queue (min-heap) to efficiently find the vertex `u` with the minimum distance during each iteration."
  },
  "solution": {
    "java": "Here's a Java solution to implement Dijkstra's shortest path algorithm:\n\n```java\nimport java.util.Arrays;\nimport java.util.PriorityQueue;\nimport java.util.List;\n\nclass Dijkstra {\n    private int n;\n    private List<int[]>[] graph;\n\n    public Dijkstra(int n, List<int[]>[] graph) {\n        this.n = n;\n        this.graph = graph;\n    }\n\n    public int[] shortestPath(int s) {\n        int[] dist = new int[n];\n        Arrays.fill(dist, Integer.MAX_VALUE);\n        dist[s] = 0;\n\n        PriorityQueue<int[]> minHeap = new PriorityQueue<>((a, b) -> a[1] - b[1]);\n        minHeap.offer(new int[]{s, 0});\n\n        while (!minHeap.isEmpty()) {\n            int[] node = minHeap.poll();\n            int u = node[0];\n            int d = node[1];\n\n            if (d > dist[u]) {\n                continue;\n            }\n\n            for (int[] edge : graph[u]) {\n                int v = edge[0];\n                int w = edge[1];\n                if (dist[u] + w < dist[v]) {\n                    dist[v] = dist[u] + w;\n                    minHeap.offer(new int[]{v, dist[v]});\n                }\n            }\n        }\n\n        return dist;\n    }\n}\n```",
    "python": "And here's a Python solution to implement Dijkstra's shortest path algorithm:\n\n```python\nclass Dijkstra:\n    def __init__(self, n, graph):\n        self.n = n\n        self.graph = graph\n\n    def shortest_path(self, s):\n        dist = [float('inf')] * self.n\n        dist[s] = 0\n\n        min_heap = [(0, s)]\n\n        while min_heap:\n            d, u = min_heap.pop(0)\n\n            if d > dist[u]:\n                continue\n\n            for v, w in self.graph[u]:\n                if dist[u] + w < dist[v]:\n                    dist[v] = dist[u] + w\n                    min_heap.append((dist[v], v))\n                    min_heap.sort()\n\n        return dist\n```"
  },
  "extras": {
    "asked": "Implementing Dijkstra's shortest path algorithm is a classic problem that assesses your understanding of graph algorithms and their applications in finding the shortest path.",
    "sdesheet": "This problem is often included in coding practice sheets to help candidates practice graph algorithms and shortest path algorithms.",
    "relatedlinks": "Related Links:\n- [Dijkstra's Algorithm on GeeksforGeeks](https://www.geeksforgeeks.org/dijkstras-shortest-path-algorithm-greedy-algo-7/)\n- [Shortest Path Algorithms on GeeksforGeeks](https://www.geeksforgeeks.org/shortest-path-algorithms/)\n- [HackerRank Dijkstra's Shortest Path Challenge](https://www.hackerrank.com/domains/tutorials/10-days-of-algorithms)"
  }
}
