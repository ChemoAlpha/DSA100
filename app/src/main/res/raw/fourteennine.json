{
  "problem_statement": {
    "title": "Q90. Word Search using Backtracking",
    "problemdescription": "Given a 2D board of characters and a word, find if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cells, where 'adjacent' cells are horizontally or vertically neighboring. Each cell may not be used more than once.",
    "problemconstraint": "Constraints:\n- 1 <= board.length, board[i].length <= 200\n- board and word consist of only lowercase and uppercase English letters.\n- 1 <= word.length <= 10^3",
    "inputformat": "Input:\n- A 2D board of characters `board` where each cell board[i][j] represents a letter.\n- A string `word` consisting of English letters.",
    "outputformat": "Output:\n- Return true if the word exists in the grid, or false otherwise.",
    "example": "Example:\n\n```python\nInput: board = [\n  ['A','B','C','E'],\n  ['S','F','C','S'],\n  ['A','D','E','E']\n], word = 'ABCCED'\nOutput: true\nExplanation: 'ABCCED' can be formed by the following path: (0,0) -> (0,1) -> (0,2) -> (1,2) -> (1,1) -> (2,1) -> (2,2).\n```"
  },
  "solution_approach": {
    "solution": "To solve the Word Search problem using backtracking, you can explore the grid using a depth-first search (DFS) approach. Start from each cell in the grid, and for each cell, perform a DFS to search for the given word. Here's an algorithmic approach:\n\n1. Iterate through each cell in the board.\n2. For each cell, perform a DFS to check if the word can be found starting from that cell.\n3. In the DFS function:\n   - Check if the current position is outside the board boundaries or if the cell has already been visited or if the current character does not match the corresponding character in the word. In these cases, return false.\n   - If the current character matches the word character, mark the cell as visited and recursively search in all four adjacent cells.\n4. If the DFS returns true for any cell, return true as the word can be found in the board. Otherwise, return false after checking all cells.\n5. The DFS should include a backtracking step where you mark the cell as unvisited before returning.",
    "hint": "You can use a recursive DFS function to traverse the board and a boolean array to keep track of visited cells. When a valid path is found, return true immediately. The recursive backtracking ensures that all possibilities are explored."
  },
  "solution": {
    "java": "Here's a Java solution to solve the Word Search problem using backtracking:\n\n```java\npublic boolean exist(char[][] board, String word) {\n    int m = board.length;\n    int n = board[0].length;\n    boolean[][] visited = new boolean[m][n];\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            if (dfs(board, word, i, j, 0, visited)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nprivate boolean dfs(char[][] board, String word, int i, int j, int index, boolean[][] visited) {\n    if (index == word.length()) {\n        return true;\n    }\n    if (i < 0 || i >= board.length || j < 0 || j >= board[0].length || visited[i][j] || board[i][j] != word.charAt(index)) {\n        return false;\n    }\n    visited[i][j] = true;\n    boolean result = dfs(board, word, i + 1, j, index + 1, visited)\n            || dfs(board, word, i - 1, j, index + 1, visited)\n            || dfs(board, word, i, j + 1, index + 1, visited)\n            || dfs(board, word, i, j - 1, index + 1, visited);\n    visited[i][j] = false;\n    return result;\n}\n```",
    "python": "And here's a Python solution to solve the Word Search problem using backtracking:\n\n```python\ndef exist(board, word):\n    def dfs(i, j, index):\n        if index == len(word):\n            return True\n        if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != word[index]:\n            return False\n        original_char = board[i][j]\n        board[i][j] = '*'\n        found = dfs(i + 1, j, index + 1) or dfs(i - 1, j, index + 1) or dfs(i, j + 1, index + 1) or dfs(i, j - 1, index + 1)\n        board[i][j] = original_char\n        return found\n\n    for i in range(len(board)):\n        for j in range(len(board[0])):\n            if dfs(i, j, 0):\n                return True\n    return False\n```"
  },
  "extras": {
    "asked": "Solving the Word Search problem using Backtracking is a common coding problem that assesses your understanding of backtracking and graph traversal.",
    "sdesheet": "This problem is often included in coding practice sheets to help candidates practice backtracking techniques and algorithmic problem-solving.",
    "relatedlinks": "Related Links:\n- [LeetCode Word Search Problem](https://leetcode.com/problems/word-search/)\n- [GeeksforGeeks Word Search Article](https://www.geeksforgeeks.org/search-a-word-in-a-2d-grid-of-characters/)\n- [HackerRank Word Search Challenge](https://www.hackerrank.com/challenges/word-search-1/)"
  }
}
