{
  "problem_statement": {
    "title": "Q88. Combination Sum using Backtracking",
    "problemdescription": "Given an array of distinct integers `candidates` and a target integer `target`, return a list of all unique combinations of `candidates` where the chosen numbers sum to `target`. You may return the combinations in any order. Each number in `candidates` may only be used once in the combination, and the same number may be chosen from `candidates` multiple times.",
    "problemconstraint": "Constraints:\n- 1 <= candidates.length <= 20\n- 1 <= candidates[i] <= 200\n- All elements of candidates are distinct.\n- 1 <= target <= 500",
    "inputformat": "Input:\n- An array of distinct integers `candidates`.\n- An integer `target`.",
    "outputformat": "Output:\n- Return a list of lists containing unique combinations of `candidates` that sum to `target`.",
    "example": "Example:\n\n```python\nInput: candidates = [2,3,6,7], target = 7\nOutput: [[2,2,3],[7]]\nExplanation: The target sum is 7, and the candidates are [2,3,6,7]. There are two unique combinations that sum to 7: [2,2,3] and [7].\n```"
  },
  "solution_approach": {
    "solution": "To find all unique combinations that sum to the target using Backtracking, you can start with an empty combination and recursively explore the possibilities. Here's an algorithmic approach:\n\n1. Sort the `candidates` array to ensure a non-decreasing order.\n2. Initialize an empty list `result` to store the valid combinations.\n3. Create a backtracking function that takes parameters: `current_combination`, `current_sum`, and `start_index`.\n4. In the backtracking function:\n   - If `current_sum` is equal to `target`, add `current_combination` to `result`.\n   - If `current_sum` exceeds `target` or we have explored all candidates, return.\n   - Iterate through the `candidates` starting from `start_index`.\n     - Add the current candidate to `current_combination`.\n     - Recursively call the backtracking function with updated parameters.\n     - Remove the last added candidate to backtrack and explore other possibilities.\n5. Call the backtracking function initially with an empty combination, sum = 0, and start index 0.\n6. Return the `result` containing all valid combinations.",
    "hint": "To avoid duplicate combinations, skip adding candidates that are the same as the previous candidate when exploring possibilities."
  },
  "solution": {
    "java": "Here's a Java solution to find all unique combinations that sum to the target using Backtracking:\n\n```java\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\nclass Solution {\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\n        Arrays.sort(candidates);\n        List<List<Integer>> result = new ArrayList<>();\n        backtrack(result, new ArrayList<>(), candidates, target, 0);\n        return result;\n    }\n\n    private void backtrack(List<List<Integer>> result, List<Integer> current, int[] candidates, int target, int start) {\n        if (target == 0) {\n            result.add(new ArrayList<>(current));\n            return;\n        }\n\n        for (int i = start; i < candidates.length && candidates[i] <= target; i++) {\n            if (i > start && candidates[i] == candidates[i - 1]) {\n                continue; // Skip duplicates\n            }\n            current.add(candidates[i]);\n            backtrack(result, current, candidates, target - candidates[i], i + 1);\n            current.remove(current.size() - 1); // Backtrack\n        }\n    }\n}\n```",
    "python": "And here's a Python solution to find all unique combinations that sum to the target using Backtracking:\n\n```python\ndef combinationSum(candidates, target):\n    def backtrack(start_index, current_combination, current_sum):\n        if current_sum == target:\n            result.append(current_combination[:])\n            return\n        if current_sum > target or start_index == len(candidates):\n            return\n        for i in range(start_index, len(candidates)):\n            current_combination.append(candidates[i])\n            backtrack(i, current_combination, current_sum + candidates[i])\n            current_combination.pop()\n\n    candidates.sort()\n    result = []\n    backtrack(0, [], 0)\n    return result\n```"
  },
  "extras": {
    "asked": "Solving the Combination Sum problem using Backtracking is a common coding problem that assesses your understanding of backtracking and recursion.",
    "sdesheet": "This problem is often included in coding practice sheets to help candidates practice backtracking techniques and algorithmic problem-solving.",
    "relatedlinks": "Related Links:\n- [LeetCode Combination Sum Problem](https://leetcode.com/problems/combination-sum/)\n- [GeeksforGeeks Combination Sum Article](https://www.geeksforgeeks.org/combinational-sum/)\n- [HackerRank Combination Sum Challenge](https://www.hackerrank.com/challenges/coin-change/)"
  }
}
