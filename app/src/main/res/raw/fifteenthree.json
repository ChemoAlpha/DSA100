{
  "problem_statement": {
    "title": "Q95. Shortest Path in an Unweighted Graph",
    "problemdescription": "Given an unweighted graph and two vertices, implement an algorithm to find the shortest path between the two vertices.",
    "problemconstraint": "Constraints:\n- The graph is represented as an adjacency list.\n- You need to find the shortest path between two given vertices.",
    "inputformat": "Input:\n- An unweighted graph represented as an adjacency list.\n- Two vertices `source` and `destination`.",
    "outputformat": "Output:\n- Return a list of vertices representing the shortest path from `source` to `destination`. If multiple shortest paths exist, return any of them.",
    "example": "Example:\n\n```\nInput:\ngraph = {\n    0: [1, 2],\n    1: [0, 3, 4],\n    2: [0, 4],\n    3: [1, 5],\n    4: [1, 2, 5],\n    5: [3, 4]\n}\nsource = 0, destination = 5\n\nOutput: [0, 1, 4, 5]\nExplanation: The shortest path from vertex 0 to vertex 5 is [0, 1, 4, 5].\n```"
  },
  "solution_approach": {
    "solution": "To find the shortest path in an unweighted graph, you can use Breadth-First Search (BFS). Here's an algorithmic approach:\n\n1. Create a function for BFS traversal.\n2. Start BFS traversal from the `source` vertex.\n3. During BFS traversal, maintain a queue to explore vertices in a breadth-first manner.\n4. Keep track of the parent of each vertex visited during BFS to reconstruct the shortest path later.\n5. When you reach the `destination` vertex, backtrack from `destination` to `source` using the parent information to construct the shortest path.\n6. Return the shortest path as a list of vertices.\n7. If no path exists from `source` to `destination`, return an empty list.",
    "hint": "You can use a queue for BFS traversal and a dictionary to store the parent of each vertex. After reaching the destination, backtrack using the parent information to find the shortest path."
  },
  "solution": {
    "java": "Here's a Java solution to find the shortest path in an unweighted graph using Breadth-First Search (BFS):\n\n```java\nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Queue;\n\npublic class ShortestPathUnweightedGraph {\n    private int vertices;\n    private List<List<Integer>> adjacencyList;\n\n    public ShortestPathUnweightedGraph(int vertices) {\n        this.vertices = vertices;\n        adjacencyList = new ArrayList<>(vertices);\n        for (int i = 0; i < vertices; i++) {\n            adjacencyList.add(new ArrayList<>());\n        }\n    }\n\n    public void addEdge(int u, int v) {\n        adjacencyList.get(u).add(v);\n        adjacencyList.get(v).add(u);\n    }\n\n    public List<Integer> findShortestPath(int source, int destination) {\n        Queue<Integer> queue = new LinkedList<>();\n        boolean[] visited = new boolean[vertices];\n        int[] parent = new int[vertices];\n        queue.offer(source);\n        visited[source] = true;\n        while (!queue.isEmpty()) {\n            int current = queue.poll();\n            if (current == destination) {\n                // Backtrack to construct the shortest path\n                List<Integer> path = new ArrayList<>();\n                int node = destination;\n                while (node != source) {\n                    path.add(node);\n                    node = parent[node];\n                }\n                path.add(source);\n                Collections.reverse(path);\n                return path;\n            }\n            for (int neighbor : adjacencyList.get(current)) {\n                if (!visited[neighbor]) {\n                    visited[neighbor] = true;\n                    parent[neighbor] = current;\n                    queue.offer(neighbor);\n                }\n            }\n        }\n        return new ArrayList<>(); // No path exists\n    }\n}\n```",
    "python": "And here's a Python solution to find the shortest path in an unweighted graph using Breadth-First Search (BFS):\n\n```python\nfrom collections import deque\n\nclass ShortestPathUnweightedGraph:\n    def __init__(self, vertices):\n        self.vertices = vertices\n        self.adjacency_list = [[] for _ in range(vertices)]\n\n    def add_edge(self, u, v):\n        self.adjacency_list[u].append(v)\n        self.adjacency_list[v].append(u)\n\n    def find_shortest_path(self, source, destination):\n        queue = deque()\n        visited = [False] * self.vertices\n        parent = [-1] * self.vertices\n        queue.append(source)\n        visited[source] = True\n        while queue:\n            current = queue.popleft()\n            if current == destination:\n                # Backtrack to construct the shortest path\n                path = []\n                node = destination\n                while node != -1:\n                    path.append(node)\n                    node = parent[node]\n                return path[::-1]\n            for neighbor in self.adjacency_list[current]:\n                if not visited[neighbor]:\n                    visited[neighbor] = True\n                    parent[neighbor] = current\n                    queue.append(neighbor)\n        return []  # No path exists\n\nif __name__ == '__main__':\n    vertices = 6\n    graph = ShortestPathUnweightedGraph(vertices)\n    graph.add_edge(0, 1)\n    graph.add_edge(0, 2)\n    graph.add_edge(1, 3)\n    graph.add_edge(2, 4)\n    graph.add_edge(3, 5)\n    source, destination = 0, 5\n    shortest_path = graph.find_shortest_path(source, destination)\n    print(f'Shortest path from {source} to {destination}: {shortest_path}')\n```"
  },
  "extras": {
    "asked": "Finding the shortest path in an unweighted graph is a common problem in graph algorithms and is often used in route planning and navigation applications.",
    "sdesheet": "This problem is often included in coding practice sheets and technical interviews to assess a candidate's understanding of graph traversal and pathfinding algorithms.",
    "relatedlinks": "Related Links:\n- [Breadth-First Search (BFS) on GeeksforGeeks](https://www.geeksforgeeks.org/breadth-first-search-or-bfs-for-a-graph/)\n- [Shortest Path in Unweighted Graphs on GeeksforGeeks](https://www.geeksforgeeks.org/shortest-path-unweighted-graph/)\n- [HackerRank Shortest Reach 2 Challenge](https://www.hackerrank.com/challenges/bfsshortreach/problem)"
  }
}
