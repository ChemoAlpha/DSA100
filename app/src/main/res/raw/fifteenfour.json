{
  "problem_statement": {
    "title": "Q96. Kruskal's Minimum Spanning Tree Algorithm",
    "problemdescription": "Implement Kruskal's algorithm to find the minimum spanning tree (MST) of a given weighted, connected graph.",
    "problemconstraint": "Constraints:\n- The graph is represented as an adjacency list with edge weights.\n- You need to find and return the edges of the minimum spanning tree (MST).\n- If multiple MSTs exist, return any of them.",
    "inputformat": "Input:\n- An integer `n` representing the number of vertices in the graph.\n- A list of tuples `edges` representing the edges of the graph, where each tuple contains three integers: `(u, v, weight)`, indicating an edge between vertex `u` and vertex `v` with the given weight.",
    "outputformat": "Output:\n- Return a list of tuples representing the edges of the minimum spanning tree (MST). Each tuple should contain `(u, v, weight)` where `u` and `v` are the vertices connected by the edge, and `weight` is the weight of the edge.",
    "example": "Example:\n\n```\nInput:\nn = 4\nedges = [(0, 1, 2), (0, 2, 4), (1, 2, 3), (1, 3, 1), (2, 3, 5)]\n\nOutput: [(1, 3, 1), (0, 1, 2), (1, 2, 3)]\nExplanation: The minimum spanning tree (MST) of the given graph includes the edges (1, 3, 1), (0, 1, 2), and (1, 2, 3), with a total weight of 6.\n```"
  },
  "solution_approach": {
    "solution": "Kruskal's algorithm is a greedy algorithm used to find the minimum spanning tree (MST) of a graph. Here's an algorithmic approach:\n\n1. Sort the edges of the graph in ascending order of their weights.\n2. Initialize an empty set `MST` to store the edges of the MST and a union-find data structure (disjoint-set) to keep track of connected components.\n3. Iterate through the sorted edges:\n   - If adding the edge to `MST` does not create a cycle, add it to `MST` and merge the two components in the union-find data structure.\n4. Continue this process until `MST` contains `n-1` edges, where `n` is the number of vertices in the graph.\n5. Return the edges in `MST` as the minimum spanning tree.",
    "hint": "You can use the union-find (disjoint-set) data structure to efficiently check whether adding an edge creates a cycle or not. Keep track of the components each vertex belongs to."
  },
  "solution": {
    "java": "Here's a Java solution to implement Kruskal's algorithm for finding the minimum spanning tree (MST):\n\n```java\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\nclass Edge implements Comparable<Edge> {\n    int u, v, weight;\n\n    public Edge(int u, int v, int weight) {\n        this.u = u;\n        this.v = v;\n        this.weight = weight;\n    }\n\n    @Override\n    public int compareTo(Edge other) {\n        return Integer.compare(this.weight, other.weight);\n    }\n}\n\npublic class KruskalsMST {\n    private int n;\n    private List<Edge> edges;\n\n    public KruskalsMST(int n, List<Edge> edges) {\n        this.n = n;\n        this.edges = edges;\n    }\n\n    public List<Edge> findMinimumSpanningTree() {\n        Collections.sort(edges);\n        List<Edge> mst = new ArrayList<>();\n        UnionFind uf = new UnionFind(n);\n\n        for (Edge edge : edges) {\n            if (uf.union(edge.u, edge.v)) {\n                mst.add(edge);\n                if (mst.size() == n - 1) {\n                    break;\n                }\n            }\n        }\n        return mst;\n    }\n}\n```",
    "python": "And here's a Python solution to implement Kruskal's algorithm for finding the minimum spanning tree (MST):\n\n```python\nclass KruskalsMST:\n    def __init__(self, n, edges):\n        self.n = n\n        self.edges = sorted(edges, key=lambda x: x[2])\n\n    def find_minimum_spanning_tree(self):\n        mst = []\n        parent = [-1] * self.n\n\n        def find(u):\n            if parent[u] == -1:\n                return u\n            parent[u] = find(parent[u])\n            return parent[u]\n\n        def union(u, v):\n            root_u = find(u)\n            root_v = find(v)\n            if root_u != root_v:\n                parent[root_u] = root_v\n                return True\n            return False\n\n        for u, v, weight in self.edges:\n            if union(u, v):\n                mst.append((u, v, weight))\n                if len(mst) == self.n - 1:\n                    break\n        return mst\n```"
  },
  "extras": {
    "asked": "Implementing Kruskal's algorithm for finding the minimum spanning tree (MST) is a common coding problem that assesses your understanding of graph algorithms and greedy strategies.",
    "sdesheet": "This problem is often included in coding practice sheets to help candidates practice graph algorithms and data structures like union-find.",
    "relatedlinks": "Related Links:\n- [Kruskal's Algorithm on GeeksforGeeks](https://www.geeksforgeeks.org/kruskals-minimum-spanning-tree-algorithm-greedy-algo-2/)\n- [Minimum Spanning Tree on GeeksforGeeks](https://www.geeksforgeeks.org/kruskals-minimum-spanning-tree-algorithm-greedy-algo-2/)\n- [HackerRank Minimum Spanning Tree Challenge](https://www.hackerrank.com/challenges/kruskalmstrsub/problem)"
  }
}
