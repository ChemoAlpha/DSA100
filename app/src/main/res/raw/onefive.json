{
  "problem_statement": {
    "title": "Q16. Implement Max Stack",
    "problemdescription": "Implement a stack data structure that supports the following operations:\n1. push(x): Pushes element x onto the stack.\n2. pop(): Removes the element on the top of the stack and returns it.\n3. top(): Returns the element on the top of the stack without removing it.\n4. peekMax(): Returns the maximum element in the stack without removing it.\n5. popMax(): Removes the maximum element in the stack and returns it. If there are multiple maximum elements, remove and return the one closest to the top.",
    "problemconstraint": "Constraints:\n- All operations should be efficient (O(1) time complexity).\n- The popMax operation should remove the topmost occurrence of the maximum element.\n- You can assume that the stack will not be empty when calling pop, top, peekMax, or popMax.",
    "inputformat": "Input:\n- Operations will be given as a sequence of strings, where each string represents one of the five operations.",
    "outputformat": "Output:\n- For the top and peekMax operations, return the element. For the pop and popMax operations, return the removed element.",
    "example": "Example:\n\nInput: [\"push(5)\", \"push(1)\", \"push(5)\", \"top()\", \"popMax()\", \"top()\", \"peekMax()\", \"pop()\", \"top()\"]\nOutput: [null, null, null, 5, 5, 1, 5, 5, 5]"
  },
  "solution_approach": {
    "solution": "To implement a Max Stack efficiently, you can use two stacks: one for the main stack and another for tracking the maximum elements. For each push operation, push the element onto the main stack and compare it with the current maximum. If it's greater or equal, push it onto the maximum stack as well. For pop operations, pop from both stacks. To implement popMax, you can first find the maximum element, remove it from both stacks, and then push back the elements that were removed from the main stack during this process.",
    "hint": "To efficiently implement a Max Stack, consider using two stacks: one for the main elements and another for tracking the maximum elements. When pushing an element, compare it with the current maximum. If it's greater or equal, push it onto the maximum stack as well. For pop operations, pop from both stacks. To implement popMax, first find the maximum element, remove it from both stacks, and then push back the elements that were removed from the main stack during this process."
  },
  "solution": {
    "java": "Here's a Java solution for implementing a Max Stack:\n\n```java\nclass MaxStack {\n    private Stack<Integer> stack;\n    private Stack<Integer> maxStack;\n\n    public MaxStack() {\n        stack = new Stack<>();\n        maxStack = new Stack<>();\n    }\n\n    public void push(int x) {\n        stack.push(x);\n        if (maxStack.isEmpty() || x >= maxStack.peek()) {\n            maxStack.push(x);\n        }\n    }\n\n    public int pop() {\n        if (stack.isEmpty()) {\n            return -1; // Stack is empty.\n        }\n        if (stack.peek().equals(maxStack.peek())) {\n            maxStack.pop();\n        }\n        return stack.pop();\n    }\n\n    public int top() {\n        if (stack.isEmpty()) {\n            return -1; // Stack is empty.\n        }\n        return stack.peek();\n    }\n\n    public int peekMax() {\n        if (maxStack.isEmpty()) {\n            return -1; // Stack is empty.\n        }\n        return maxStack.peek();\n    }\n\n    public int popMax() {\n        if (maxStack.isEmpty()) {\n            return -1; // Stack is empty.\n        }\n        int max = maxStack.pop();\n        Stack<Integer> temp = new Stack<>();\n        while (!stack.isEmpty() && !stack.peek().equals(max)) {\n            temp.push(stack.pop());\n        }\n        stack.pop();\n        while (!temp.isEmpty()) {\n            push(temp.pop());\n        }\n        return max;\n    }\n}\n```\nThis Java code efficiently implements a Max Stack with support for push, pop, top, peekMax, and popMax operations.",
    "python": "And here's a Python solution for implementing a Max Stack:\n\n```python\nclass MaxStack:\n    def __init__(self):\n        self.stack = []\n        self.maxStack = []\n\n    def push(self, x: int) -> None:\n        self.stack.append(x)\n        if not self.maxStack or x >= self.maxStack[-1]:\n            self.maxStack.append(x)\n\n    def pop(self) -> int:\n        if not self.stack:\n            return -1  # Stack is empty.\n        if self.stack[-1] == self.maxStack[-1]:\n            self.maxStack.pop()\n        return self.stack.pop()\n\n    def top(self) -> int:\n        if not self.stack:\n            return -1  # Stack is empty.\n        return self.stack[-1]\n\n    def peekMax(self) -> int:\n        if not self.maxStack:\n            return -1  # Stack is empty.\n        return self.maxStack[-1]\n\n    def popMax(self) -> int:\n        if not self.maxStack:\n            return -1  # Stack is empty.\n        maxVal = self.maxStack.pop()\n        temp = []\n        while self.stack and self.stack[-1] != maxVal:\n            temp.append(self.stack.pop())\n        self.stack.pop()  # Remove the maxVal\n        while temp:\n            self.push(temp.pop())\n        return maxVal\n```\nThis Python code efficiently implements a Max Stack with support for push, pop, top, peekMax, and popMax operations."
  },
  "extras": {
    "asked": "Implementing a Max Stack is a challenging coding interview question and is commonly asked to assess candidates' understanding of stack data structures and algorithm design.",
    "sdesheet": "This problem is often included in coding practice sheets and is a valuable exercise for learning how to maintain additional information alongside a stack.",
    "relatedlinks": "Related Links:\n- [LeetCode Max Stack Problem](https://leetcode.com/problems/max-stack/)\n- [GeeksforGeeks Implement a Max Stack Article](https://www.geeksforgeeks.org/design-and-implement-special-stack-data-structure/)\n- [HackerRank Max Element in a Stack Challenge](https://www.hackerrank.com/challenges/maximum-element)"
  }
}
