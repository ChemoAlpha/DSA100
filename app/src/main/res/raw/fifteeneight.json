{
  "problem_statement": {
    "title": "Q100. Floyd-Warshall Algorithm",
    "problemdescription": "Given a weighted, directed graph represented as an adjacency matrix, implement the Floyd-Warshall algorithm to find the shortest distances between all pairs of vertices in the graph. The algorithm should handle negative weight edges and should return a matrix where `dist[i][j]` represents the shortest distance from vertex `i` to vertex `j`. If there is no path between vertex `i` and vertex `j`, the corresponding entry in the matrix should be infinity (or a very large value).",
    "problemconstraint": "Constraints:\n- The input graph is represented as an `n x n` adjacency matrix where `n` is the number of vertices (2 <= n <= 200).\n- Edge weights can be positive, negative, or zero, and there can be self-loops with zero weight.\n- The diagonal elements of the adjacency matrix (i.e., `dist[i][i]`) are always 0, representing no distance to itself.",
    "inputformat": "Input:\n- An `n x n` integer matrix `graph` representing the weighted, directed graph. The entry `graph[i][j]` indicates the weight of the edge from vertex `i` to vertex `j` or 0 if no direct edge exists.",
    "outputformat": "Output:\n- Return an `n x n` integer matrix `dist` where `dist[i][j]` represents the shortest distance from vertex `i` to vertex `j` for all pairs of vertices.",
    "example": "Example:\n\n```\nInput:\ngraph = [[0, 5, inf, 10], [inf, 0, 3, inf], [inf, inf, 0, 1], [inf, inf, inf, 0]]\n\nOutput:\n[[0, 5, 8, 9], [inf, 0, 3, 4], [inf, inf, 0, 1], [inf, inf, inf, 0]]\n```"
  },
  "solution_approach": {
    "solution": "The Floyd-Warshall algorithm is used to find the shortest distances between all pairs of vertices in a weighted, directed graph. Here's an algorithmic approach:\n\n1. Initialize a 2D matrix `dist` of size `n x n`, where `n` is the number of vertices, to represent the shortest distances between all pairs of vertices.\n2. Initialize `dist` such that `dist[i][j]` is the weight of the edge from vertex `i` to vertex `j` if it exists, or infinity (or a very large value) if no direct edge exists. Initialize the diagonal elements of `dist` to 0.\n3. Iterate through all vertices `k` from 0 to `n-1` and, for each `k`, iterate through all pairs of vertices `i` and `j`.\n   - Update `dist[i][j]` to `min(dist[i][j], dist[i][k] + dist[k][j])`. This step ensures that if there is a shorter path from `i` to `j` through vertex `k`, it updates `dist[i][j]` accordingly.\n4. After the algorithm completes, the `dist` matrix contains the shortest distances between all pairs of vertices.\n5. Return the `dist` matrix as the result.",
    "hint": "The algorithm can handle negative weight edges and can be used to detect negative weight cycles. If the `dist` matrix has any negative values on its diagonal after the algorithm completes, it indicates the presence of a negative weight cycle in the graph."
  },
  "solution": {
    "java": "Here's a Java solution to implement the Floyd-Warshall algorithm:\n\n```java\nclass FloydWarshall {\n    public int[][] shortestPaths(int[][] graph) {\n        int n = graph.length;\n        int[][] dist = new int[n][n];\n\n        // Initialize dist matrix\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                dist[i][j] = graph[i][j];\n            }\n        }\n\n        // Floyd-Warshall algorithm\n        for (int k = 0; k < n; k++) {\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    if (dist[i][k] != Integer.MAX_VALUE &&\n                        dist[k][j] != Integer.MAX_VALUE &&\n                        dist[i][k] + dist[k][j] < dist[i][j]) {\n                        dist[i][j] = dist[i][k] + dist[k][j];\n                    }\n                }\n            }\n        }\n\n        return dist;\n    }\n}\n```",
    "python": "And here's a Python solution to implement the Floyd-Warshall algorithm:\n\n```python\nclass FloydWarshall:\n    def shortest_paths(self, graph):\n        n = len(graph)\n        dist = [list(row) for row in graph]\n\n        # Floyd-Warshall algorithm\n        for k in range(n):\n            for i in range(n):\n                for j in range(n):\n                    if dist[i][k] != float('inf') and dist[k][j] != float('inf'):\n                        dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n\n        return dist\n```"
  },
  "extras": {
    "asked": "Implementing the Floyd-Warshall algorithm is a classic problem in graph theory and is widely used for finding shortest paths in various applications, including network routing and transportation planning.",
    "sdesheet": "This problem is often included in coding practice sheets to help candidates practice dynamic programming techniques and graph algorithms.",
    "relatedlinks": "Related Links:\n- [Floyd-Warshall Algorithm on GeeksforGeeks](https://www.geeksforgeeks.org/floyd-warshall-algorithm-dp-16/)\n- [Shortest Path Algorithms on GeeksforGeeks](https://www.geeksforgeeks.org/shortest-path-algorithms/)\n- [HackerRank Floyd-Warshall Algorithm Challenge](https://www.hackerrank.com/domains/tutorials/10-days-of-algorithms)"
  }
}
